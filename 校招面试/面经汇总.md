## 给我讲讲hashMap 

   >hashMap使用Node节点保存key-value,其中还有一个存储Node节点的数组作为hash桶，当调用put方法时，hashmap首先计算出key的hash值，并通过计算所得的hash值算出在数组中的位置。若数组中该位置为空，则直接将Node插入数组中，若不为空，则判断与该位置节点的key是否相同，相同则替换原value为新value。若不同，则判断该节点是否为TreeNode，如果是树节点，则执行红黑树插入操作，如果不是，则将节点通过尾插法插入链表。插入完成后，判断是否需要对数组扩容。

## 我有一个Student对象，如果使用hashMap，需要重写什么 

> 如果将Student作为key来使用，则需要重写equals方法和hashcode方法。

## 扰动的算法

> 计算得到的hash值是一个int型，如果只是取低位的hash值很容易造成低位相同，高位不同的hash值发生碰撞，所以hashmap采用了扰动的方式，将hash值的高16位与低16位进行异或得到一个更加散列的16位的hash值

## 扩容机制

> 在JDK1.8之后，当第一次调用put方法会进行扩容，此时的扩容是初始化数组，数组大小为第一个大于设定值的2的幂来初始化，如果未设定初始值，会使用16来进行初始化。如果hashmap中的节点数量超过了负载因子定义的容量，则进行hash数组的扩容，将数组扩大为两倍，并将元素进行迁移。

## 枚举类，避免多个if

 

## 讲一讲同步锁（Synchronized和Lock） 

> Synchronized 是java提供的关键字，是悲观非公平锁，是可重入锁，不需要程序员手动释放锁，线程出现异常时也可以自动释放锁。底层是使用指令码来实现的，monitorenter和monitorexit。是不可中断锁。
>
> Lock是一个接口，Lock需要手动释放锁，所以应该在finally中释放锁，Lock更加灵活，可以对不同的condition进行等待和唤醒操作，实现精准唤醒。是可中断锁。//底层是使用乐观锁来实现的

## 输入URL的过程

> 1. 在浏览器中输入URL时，浏览器会在缓存中加载相关URL并提示，当按下回车后，便进行DNS域名解析，首先在浏览器缓存中查询相关的解析结果，如果没有再去本地hosts文件查询，找不到的话去询问ISP中是否有对应的ip地址，如果没有ISP会向根DNS服务器进行查询，根服务器中如果没有，便递归向子服务器进行查询。查询到对应的ip之后，会将对应关系保存在缓存中以备下次查询
> 2. 查询到ip地址后，向服务器建立请求建立TCP连接，客户端发送包含SYN=1，seq=X的TCP连接请求，服务端接收到后，向客户端发送SYN=1，seq=Y，ACK=1，ACKnum=X+1的连接请求，客户端接收到后，发送ACK=1.ACKnub=Y+1的确认包，服务器接收到之后，双方进入EStablished状态。此时TCP连接建立成功。
> 3. 客户端向服务端发送HTTP请求，请求报文分为请求行，请求头，请求正文 请求行包含请求方法、URL、协议版本 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。
> 4. 服务端处理请求并返回HTTP报文 
> 5. 浏览器根据HTTP报文进行页面渲染。
> 6. 断开TCP连接

## spring、springMvc、springBoot和springCloud

> **spring和springMvc：**
>
> 1. spring是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案；
>
> 2. springMvc是spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于spring框架中WEB层开发的一部分；
>
> **springMvc和springBoot：**
>
> 1. springMvc属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂；
> 2. springBoot框架相对于springMvc框架来说，更专注于开发微服务后台接口，不开发前端视图；
>
> **springBoot和springCloud：**
>
> 1. spring boot使用了默认大于配置的理念，集成了快速开发的spring多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置，是一套快速配置开发的脚手架，能快速开发单个微服务；
>
> 2. spring cloud大部分的功能插件都是基于springBoot去实现的，springCloud关注于全局的微服务整合和管理，将多个springBoot单体微服务进行整合以及管理； springCloud依赖于springBoot开发，而springBoot可以独立开发；
>
> **总结：**
>
> 1. Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring的ioc、aop等. ioc 提供了依赖注入的容器， aop解决了面向横切面编程，然后在此两者的基础上实现了其他延伸产品的高级功能；
>
> 2. springMvc是基于Servlet 的一个MVC框架主要解决WEB开发的问题，因为Spring的配置非常复杂，各种XML、JavaConfig、servlet处理起来比较繁琐；
>
> 3. 为了简化开发者的使用，从而创造性地推出了springBoot框架，默认优于配置，简化了springMvc的配置流程；
>    但区别于springMvc的是，springBoot专注于微服务方面的接口开发，和前端解耦，虽然springBoot也可以做成springMvc前后台一起开发，但是这就有点不符合springBoot框架的初衷了；
>
> 4. 对于springCloud框架来说，它和springBoot一样，注重的是微服务的开发，但是springCloud更关注的是全局微服务的整合和管理，相当于管理多个springBoot框架的单体微服务；

## springboot自动装配

>SpringBoot首先可以看到启动类上的注解是SpringBootApplication，这个注解包括了Configuration、EnableAutoConfiguration、ComponentScan三个注解，自动装配的核心注解就是EnableAutoConfiguration，这个注解的注释引导我们去看AutoConfigurationImportSelector这个类，这个类实现了ImportSelector接口中的selectImport方法，这个方法从meta-inf/Spring.factories中加载所要自动装配的类并将这些类加载到IOC容器中，自动装配就完成了

## redis跳表以及为什么要用跳表

> 跳表是一种有序的多层的链表，跳表的复杂度与红黑树相同，跳表更容易代码实现也更加易读，跳表区间查找效率更高。

## redis你都用来干什么(说了缓存和分布式锁)

## redis分布式锁

## 一致性hash

  > 一致性hash是在哈希算法的基础上提出的，在动态变化的分布式环境中，一致性哈希可以保证平衡性，单调性，分散性。
  >
  > 他是通过一个叫做一致性哈希环的数据结构来实现的，环的起点是0，终点是2^32^-1,起点与终点连接，计算所得的hash值会被放在环上。
  >
  > 服务器首先计算哈希值并被放在环上，当有对象请求时，计算对象的哈希值并放在环上，所请求的服务器便是顺时针距离对象最近的服务器。
  >
  > 一致性哈希算法可以有效解决分布式系统中，增加或下线服务器造成的缓存大面积失效的情况

## mysql底层数据结构

InnoDB 和 Myisam 都是用 B+Tree 来存储数据的。

## mysql存储引擎区别

> InnoDB 支持事务，MyISAM 不支持事务。
>
> InnoDB 支持外键，而 MyISAM 不支持。
>
> InnoDB 是聚集索引，MyISAM 是非聚集索引。
>
> InnoDB 不保存表的具体行数
>
> InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。
>
> 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。
>
> MyISAM：每个MyISAM在磁盘上存储成三个文件。分别存储表定义、数据、索引
> InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。存储为两个文件 .frm .ibd
>
> 
>
> MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。
> InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。
>
> 
>
> 聚集索引与非聚集索引：聚集索引将数据储存在叶节点中，并且物理上按索引顺序保存。非聚集索引在逻辑上按索引顺序保存，在物理上按插入顺序存储。

## spring ioc

> 在使用spring之前，程序的对象创建完全由程序本身控制，模块间耦合度很高且不好维护。
>
> ioc 控制反转 将对象的创建交给spring来控制，只需要在需要添加到spring的类上添加compont注解并在配置文件中添加要扫描的包，spring便回自动扫描并装配到容器中。

## spring循环依赖

> spring在创建对象时会首先获取对象或半成品的对象，如果获取不到则再创建对象，如果A对象中引用了其他对象B，也会首先尝试获取对象B，获取不到则对B进行初始化，如果B中又引用了A，则此时会返回半成品的A，B对象就构造完成，将B对象返回至A中，A对象构造完成。

## rabbitmq消息队列及底层实现原理

## java里边的锁都有哪些

> 乐观锁、悲观锁、可重入锁、自旋锁、读写锁、互斥锁、公平锁、非公平锁、独享锁、共享锁

## synchronize和lock的区别

> synchronized是java提供的关键字 lock是一个接口， synchronized是非公平锁，lock可以设置公平锁或非公平锁，synchronized不能实现按条件唤醒，要么唤醒一个，要么全部唤醒，lock可以实现按condition唤醒，实现精准唤醒。synchronized会自动释放锁，lock需要手动释放锁，所以一般lock的释放要放在finally代码块中，synchronized不可中断，lock是可中断锁。

## countdownlatch和cyclicbarrier的区别

> countdownlatch是减法计数器，当计数器减至0时释放锁，cyclicbarrier是加法计数器，计数器加到指定值时释放锁

| CountDownLatch                                               | CyclicBarrier                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 减计数方式                                                   | 加计数方式                                                   |
| 计算为0时释放所有等待的线程                                  | 计数达到指定值时释放所有等待线程                             |
| 计数为0时，无法重置                                          | 计数达到指定值时，计数置为0重新开始                          |
| 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 |
| 不可重复利用                                                 | 可重复利用                                                   |

## jvm方法区里都有什么,方法区会oom吗

> - 方法区主要存储虚拟机加载的类信息、常量、静态变量、及编译器编译后的代码缓存、类加载器。
> - 方法区同样会发生OOM

## AtomicInteger底层实现

> AtomicInteger底层使用volatile修饰了value保证可见性并调用了unsafe类的compareAndAddInt方法，是本地方法，使用自旋锁实现。

## jvm内存结构

> JVM中包含堆、栈、本地方法栈、程序计数器、方法区。
>
> 堆是线程共享，存储创建的对象。
>
> 栈是线程私有，存储局部变量表、操作栈、动态链接、方法出口、对象指针等信息。
>
> 本地方法栈是线程共享，存储本地方法。
>
> 程序计数器是线程私有，存储线程执行的下一条语句。
>
> 方法区是线程共享，存储静态变量、类信息、常量

## 类加载器，创建一个String对象的过程，创建一个类在内存中的过程

> 类加载器分为启动类加载器，扩展类加载器，系统类加载器，用户自定义的类加载器
>
> 会首先创建一个String对象，对于初始的字符串会去字符串常量池中寻找字符串，如果存在则返回，不存在则创建一个字符串放在字符串常量池中。
>
> 创建类，首先为检查是否有父类，为父类分配空间并按照代码顺序初始化static常量和执行static方法，再加载子类的static常量和static方法，再初始化父类的普通变量和代码块和构造器，最后初始化子类的普通变量并执行代码块和构造器。

## 双亲委派模型，一个同包同名的类如何加载。

> 双亲委派模型即类加载器在加载一个类时，首先要求父级加载器加载，可以有效防止java核心包被篡改。
>
> 如果两个包属于不同类加载器加载，那么优先加载所属加载器级别更高的那个类，如果属于同一个类加载器，则根据系统的文件排序加载先被扫描的类。

## 100000000个数找中位数

> 如果可以放入内存，则随机取一个数，将比这个数小的值放在左边，比这个数大的值放在右边。操作完成后可以知道选取的数字是第几大数字，如果该数字比中位数小，则对该数字右侧进行同样操作，一直取到第50000000大数字和第50000001大数字取平均值。
>
> 如果不能放入内存，首先按照内存大小计算出组数，比如内存中可以存放10000000个数字，则将数据分为100000000/10000000=10组，第一组存放值位于1~10000000区间的数字，以次类推，通过统计每组的容量可以得出数字位于哪个组中，再通过方式一求得中位数。

## http，为什么用TCP

> 答案未知！
>
> TCP是可靠的传输，在之前的网络中，UDP经常出现丢包现象，这会造成HTTP解析失败，需要因此重传多次数据，这样造成的损失远远大于TCP传输。
>
> 如今的网络连接质量越来越好，丢包现象罕见，在HTTP3.0中便使用了UDP进行传输，这样可以减少服务器的连接数，大幅提高服务器的性能。

## 三次握手，DNS为什么用UDP

> 客户端先发送一个带有请求建立连接的状态码SYN=1和一个序列码seq=X数据包给服务器代表请求连接服务器，服务器收到数据包后回复带有ACK=1 ACKnum=X+1      SYN=1 seq=Y的数据包给客户端，客户端收到后发送带有ACK=1和ACKnum=Y+1的数据包给服务器并进入ESTABLISHED状态，服务器收到数据包后也进入ESTABLISHED状态，连接正式建立。       

## 输入网址到返回页面的过程

> 在输入网址的过程中，浏览器会搜索缓存和历史记录补全地址，按下enter键之后浏览器会查找URL对应的IP地址，首先从浏览器缓存中查找，如果没有则去本机HOSTS文件查找，如果仍没有则询问ISP，ISP如果没有则去询问URL所在的根DNS服务器，根DNS服务器中如果没有则递归查询子DNS服务器，一旦找到则在缓存中存储URL与IP的对应关系。
>
> 此时浏览器会发送请求建立TCP连接，发送一个包含SYN=1，seq=X的数据包，服务器接收到数据包后会回复一个含有SYN=1，seq=Y，ACK=1，ACKnum=X+1的数据包，客户端接收到服务器的数据包后会发送含有ACK=1，ACKnum=Y+1的数据包，此时客户端进入ESTABLISH状态，服务器收到数据包之后也会进入ESTABLISH状态，连接正式建立。
>
> 服务器处理请求并将页面返回给客户端

## Mysql为什么用B+树，

> b+树首先是按照关键字的顺序进行排序的，这对于一些范围查询的语句来说是可以加快搜索，B+树的一个节点可以设置为磁盘的页大小，加载一整个节点只需要一次磁盘IO，B+树高度较低，也可以减少磁盘IO，所以B+树对于磁盘来说读写性能是最高的。
>
> 磁盘读写代价更低
>
> 查询效率更稳定
>
> B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

## 非聚类索引，聚类索引

> 聚类索引就是将数据和索引存放在一起，一般主键是聚类索引。
>
> 非聚类索引是不存放数据的，可以通过索引查询到主键的值，再通过主键对应的聚类索引查找到真正的数据。

## 二叉树蛇形打印

> 使用两个栈，遍历过的节点放入第一个栈中,将第一个栈遍历得到的节点按右子节点、左子节点的顺序压入第二个栈中，第一个栈空之后遍历第二个栈，将第二个栈遍历得到的节点按左子节点、右子节点的顺序压入第一个栈中，重复操作直到遍历完成。

## 秒杀三问题: 高并发, 少卖, 超卖. 问题描述和解决方法

> 秒杀具有**时间短、并发量大的特点**，秒杀持续时间只有几分钟，而一般公司都为了制造轰动效应，会以极低的价格来吸引用户，因此参与抢购的用户会非常的多。短时间内会有大量请求涌进来，后端如何**防止并发过高造成缓存击穿或者失效**，**击垮数据库**都是需要考虑的问题。
>
> 前端限流，每5秒点击1次
>
> 同一用户xx秒内超过阈值请求直接拒绝。
>
> 第一种加锁：悲观锁乐观锁
>
> 第二种：redis+mq
>
> 异步下单。
>
> 细节未知

## MySQL buffer pool和doublewrite buffer

> buffer pool是MYSQL的缓存池，用于存放之前查询到的数据，每次查询MYSQL都会先去buffer pool中查询，如果有结果则直接返回结果，如果查询不到则从磁盘中加载数据记录到buffer pool。
>
> 

RocketMQ事务性消息

RocketMQ相对于其他消息队列的优点(Kafaka权威指南那本书真该做笔记的)

RateLimiter和令牌桶算法(RateLimiter源码没看, 下来该看了)

> 

## 封装, 继承, 多态

> 封装是指一个类将属性和实现方法隐藏起来，只留下外部可以调用接口。控制在程序中属性读和写的访问级别。
>
> 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
>
> 多态是同一个行为具有多个不同表现形式或形态的能力。

## 重载和重写

> 重载是写了两个不同的方法，只是方法名相同，方法的参数必须不同，方法的返回值和异常都可以不同。
>
> 重写是子类对父类的方法进行重写，要求方法名，参数都相同，返回值是父类返回值的派生类，抛出的异常小于父类的异常才可以。

## 强软弱虚，每种引用的使用场景

> 强引用即使用=赋值的引用，只要引用还在，垃圾回收器就不会回收该引用所指向的对象。最普通的引用
>
> 软引用即使用SoftReference类包装的引用，当内存足够时，垃圾回收器不会回收该引用，内存不足时，垃圾回收器会进行回收。可以是在排除过期数据的情况下。JDK中有个类叫ResourceBundle，内部会使用ConcurrentMap缓存ResourceBundle对象，这里就是使用的软引用机制。
>
> 弱引用即使用WeakReference类包装的引用，只要垃圾回收器进行回收，则该对象会被回收。是在较为复杂的数据结构中，为了避免内存泄露而使用的一种引用方式。
> 下面说一下ThreadLocal中对弱引用的使用。
>
> 虚引用即使用pxxx类包装的引用，非实际引用，无法获取引用的对象，只有在垃圾回收该对象时，放入回收队列中，可以进行某些操作。虚引用的目的就是为了得知对象被GC的时机，所以可以利用虚引用来进行销毁前的一些操作，比如说资源释放等。这个虚引用对于对象而言完全是无感知的，有没有完全一样，但是对于虚引用的使用者而言，就像是待观察的对象的把脉线，可以通过它来观察对象是否已经被回收，从而进行相应的处理。虚引用有一个很重要的用途就是用来做堆外内存的释放，DirectByteBuffer就是通过虚引用来实现堆外内存的释放的。



## ThreadLocal的key为什么使用弱引用

> 如果key使用强引用的话，即使在线程中已经不再使用这个key，gc回收器也无法对key进行回收，会造成内存溢出的现象。

## 对象内存布局(数组对象会多一部分)

![img](images/1162587-20200918154115022-312986152.png)

- **锁标志位（lock）**：区分锁状态，11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。
- **biased_lock**：是否偏向锁，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。
- **分代年龄（age）**：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。
- **对象的hashcode（hash）**：运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。
- **偏向锁的线程ID（JavaThread）**：偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。
- **epoch**：偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。
- **ptr_to_lock_record**：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。
- **ptr_to_heavyweight_monitor**：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。

> 首先是mark word，占用8个字节，包括hashcode，GC信息，锁信息，其次是klass point，即类型指针，是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。之后就是实例数据，最后还有可能有对齐数据。

## 锁升级过程. (好久没看了, 大概说了一下, 值得一提的是JDK15以后取消了对偏向锁的使用).

> 首先是偏向锁状态，此时锁的MarkWord中存放的是持有锁的线程1的ID，如果此时有其他线程获取锁，会使用CAS修改锁的Markword，偏向锁状态升级成轻量级锁，如果某个线程执行CAS操作获取锁的次数超过了阈值，轻量锁再升级成重量级锁。

简单算法题: 求链表中倒数第k个元素

> 创建两个指针，第一个指针先走k个元素，两个指针再同时开始向后遍历，当第一个指针到链表的最后的时候，第二个指针所在的位置就是倒数第k个元素。

MySQL锁

> MySQL有行锁和表锁，表锁一般是MyISAM使用，分为读锁和写锁，在执行select语句时会加读锁，执行update、insert、delete等操作时会加写锁，优点是加锁快，不会产生死锁，缺点是并发操作效率极低。行锁一般是Innodb引擎使用，有排他锁、共享锁、意向排他锁、意向共享锁，排他锁是在修改操作时加锁，阻塞其他事务的读和写，共享锁是在读数据前加锁，阻塞其他事务的写操作，在加排他锁之前首先要获取意向排他锁，同理在加共享锁之前也要加意向共享锁。

Redis缓存

异步化扣减库存

异步事务具体过程

高并发下的文件事件调度器

依赖注入和循环依赖

> 

自动配置全流程(`ImporterSelector`, `Registry`, `ConfigurationPostProcessor`, `loadFactoryName`, `META-INF/spring.factories`)



RedLock[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)(这个聊了很久, 其实单看Redis的[doc](https://redis.io/topics/distlock)是没用的, 我建议看看DDIA的第二部分, 尤其是分布式系统的麻烦中, 一致和共识那两部分).

Git版本控制

CI

说说自动配置和反射

为什么要四次挥手，第四次挥手的状态

> 

线程池了解吗

进程与线程的区别

Java并发是如何进行的

数据库事务的四个隔离阶段

每个隔离阶段分别隔离什么

可重复读跟幻读的区别

Hashmap跟hashtable的区别

索引，为什么要用B+索引，B+索引跟B树索引有啥区别

都有哪些搜索引擎

Innodb搜索引擎主要用啥索引

聚簇索引跟非聚簇索引的区别

数据库里面有哪些锁

Select a,b,c from 表，创建索引

Select a,b,c from 表，where a>1 and b=1;创建索引

为什么要这样创建，加快查询速率，减少回表

Mysql清空一个表的操作





