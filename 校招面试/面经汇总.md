## 给我讲讲hashMap 

   >hashMap使用Node节点保存key-value,其中还有一个存储Node节点的数组作为hash桶，当调用put方法时，hashmap首先计算出key的hash值，并通过计算所得的hash值算出在数组中的位置。若数组中该位置为空，则直接将Node插入数组中，若不为空，则判断与该位置节点的key是否相同，相同则替换原value为新value。若不同，则判断该节点是否为TreeNode，如果是树节点，则执行红黑树插入操作，如果不是，则将节点通过尾插法插入链表。插入完成后，判断是否需要对数组扩容。

## 我有一个Student对象，如果使用hashMap，需要重写什么 

> 如果将Student作为key来使用，则需要重写equals方法和hashcode方法。

## 扰动的[算法]() 

> 计算得到的hash值是一个int型，如果只是取低位的hash值很容易造成低位相同，高位不同的hash值发生碰撞，所以hashmap采用了扰动的方式，将hash值的高16位与低16位进行异或得到一个更加散列的16位的hash值

## 扩容机制 

> 在JDK1.8之后，当第一次调用put方法会进行扩容，此时的扩容是初始化数组，数组大小为第一个大于设定值的2的幂来初始化，如果未设定初始值，会使用16来进行初始化。如果hashmap中的节点数量超过了负载因子定义的容量，则进行hash数组的扩容，将数组扩大为两倍，并将元素进行迁移。

## 枚举类，避免多个if 

 

## 讲一讲同步锁（Synchronized和Lock） 

> Synchronized 是java提供的关键字，是悲观非公平锁，是可重入锁，不需要程序员手动释放锁，线程出现异常时也可以自动释放锁。底层是使用指令码来实现的，monitorenter和monitorexit。是不可中断锁。
>
> Lock是一个接口，Lock需要手动释放锁，所以应该在finally中释放锁，Lock更加灵活，可以对不同的condition进行等待和唤醒操作，实现精准唤醒。是可中断锁。//底层是使用乐观锁来实现的

## 输入URL的过程

> 1. 在浏览器中输入URL时，浏览器会在缓存中加载相关URL并提示，当按下回车后，便进行DNS域名解析，首先在浏览器缓存中查询相关的解析结果，如果没有再去本地hosts文件查询，找不到的话去询问ISP中是否有对应的ip地址，如果没有ISP会向根DNS服务器进行查询，根服务器中如果没有，便递归向子服务器进行查询。查询到对应的ip之后，会将对应关系保存在缓存中以备下次查询
> 2. 查询到ip地址后，向服务器建立请求建立TCP连接，客户端发送包含SYN=1，seq=X的TCP连接请求，服务端接收到后，向客户端发送SYN=1，seq=Y，ACK=1，ACKnum=X+1的连接请求，客户端接收到后，发送ACK=1.ACKnub=Y+1的确认包，服务器接收到之后，双方进入EStablished状态。此时TCP连接建立成功。
> 3. 客户端向服务端发送HTTP请求，请求报文分为请求行，请求头，请求正文 请求行包含请求方法、URL、协议版本 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。
> 4. 服务端处理请求并返回HTTP报文 
> 5. 浏览器根据HTTP报文进行页面渲染。
> 6. 断开TCP连接

## spring、springMvc、springBoot和springCloud

> **spring和springMvc：**
>
> 1. spring是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案；
>
> 2. springMvc是spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于spring框架中WEB层开发的一部分；
>
> **springMvc和springBoot：**
>
> 1. springMvc属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂；
> 2. springBoot框架相对于springMvc框架来说，更专注于开发微服务后台接口，不开发前端视图；
>
> **springBoot和springCloud：**
>
> 1. spring boot使用了默认大于配置的理念，集成了快速开发的spring多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置，是一套快速配置开发的脚手架，能快速开发单个微服务；
>
> 2. spring cloud大部分的功能插件都是基于springBoot去实现的，springCloud关注于全局的微服务整合和管理，将多个springBoot单体微服务进行整合以及管理； springCloud依赖于springBoot开发，而springBoot可以独立开发；
>
> **总结：**
>
> 1. Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring的ioc、aop等. ioc 提供了依赖注入的容器， aop解决了面向横切面编程，然后在此两者的基础上实现了其他延伸产品的高级功能；
>
> 2. springMvc是基于Servlet 的一个MVC框架主要解决WEB开发的问题，因为Spring的配置非常复杂，各种XML、JavaConfig、servlet处理起来比较繁琐；
>
> 3. 为了简化开发者的使用，从而创造性地推出了springBoot框架，默认优于配置，简化了springMvc的配置流程；
>    但区别于springMvc的是，springBoot专注于微服务方面的接口开发，和前端解耦，虽然springBoot也可以做成springMvc前后台一起开发，但是这就有点不符合springBoot框架的初衷了；
>
> 4. 对于springCloud框架来说，它和springBoot一样，注重的是微服务的开发，但是springCloud更关注的是全局微服务的整合和管理，相当于管理多个springBoot框架的单体微服务；

## springboot自动装配

>SpringBoot首先可以看到启动类上的注解是SpringBootApplication，这个注解包括了Configuration、EnableAutoConfiguration、ComponentScan三个注解，自动装配的核心注解就是EnableAutoConfiguration，这个注解的注释引导我们去看AutoConfigurationImportSelector这个类，这个类实现了ImportSelector接口中的selectImport方法，这个方法从meta-inf/Spring.factories中加载所要自动装配的类并将这些类加载到IOC容器中，自动装配就完成了

## redis跳表以及为什么要用跳表

> 跳表是一种有序的多层的链表，跳表的复杂度与红黑树相同，跳表更容易代码实现也更加易读，跳表区间查找效率更高。

## redis你都用来干什么(说了缓存和分布式锁)

## redis分布式锁

## 一致性hash

  > 一致性hash是在哈希算法的基础上提出的，在动态变化的分布式环境中，一致性哈希可以保证平衡性，单调性，分散性。
  >
  > 他是通过一个叫做一致性哈希环的数据结构来实现的，环的起点是0，终点是2^32^-1,起点与终点连接，计算所得的hash值会被放在环上。
  >
  > 服务器首先计算哈希值并被放在环上，当有对象请求时，计算对象的哈希值并放在环上，所请求的服务器便是顺时针距离对象最近的服务器。
  >
  > 一致性哈希算法可以有效解决分布式系统中，增加或下线服务器造成的缓存大面积失效的情况

## mysql底层数据结构

InnoDB 和 Myisam 都是用 B+Tree 来存储数据的。

## mysql存储引擎区别

> InnoDB 支持事务，MyISAM 不支持事务。
>
> InnoDB 支持外键，而 MyISAM 不支持。
>
> InnoDB 是聚集索引，MyISAM 是非聚集索引。
>
> InnoDB 不保存表的具体行数
>
> InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。
>
> 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。
>
> MyISAM：每个MyISAM在磁盘上存储成三个文件。分别存储表定义、数据、索引
> InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。存储为两个文件 .frm .ibd
>
> 
>
> MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。
> InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。
>
> 
>
> 聚集索引与非聚集索引：聚集索引将数据储存在叶节点中，并且物理上按索引顺序保存。非聚集索引在逻辑上按索引顺序保存，在物理上按插入顺序存储。

## spring ioc

> 在使用spring之前，程序的对象创建完全由程序本身控制，模块间耦合度很高且不好维护。
>
> ioc 控制反转 将对象的创建交给spring来控制，只需要在需要添加到spring的类上添加compont注解并在配置文件中添加要扫描的包，spring便回自动扫描并装配到容器中。

## spring循环依赖

> spring在创建对象时会首先获取对象或半成品的对象，如果获取不到则再创建对象，如果A对象中引用了其他对象B，也会首先尝试获取对象B，获取不到则对B进行初始化，如果B中又引用了A，则此时会返回半成品的A，B对象就构造完成，将B对象返回至A中，A对象构造完成。

## rabbitmq消息队列及底层实现原理

## java里边的锁都有哪些

> 乐观锁、悲观锁、可重入锁、自旋锁、读写锁、互斥锁、公平锁、非公平锁、独享锁、共享锁

## synchronize和lock的区别

> synchronized是java提供的关键字 lock是一个接口， synchronized是非公平锁，lock可以设置公平锁或非公平锁，synchronized不能实现按条件唤醒，要么唤醒一个，要么全部唤醒，lock可以实现按condition唤醒，实现精准唤醒。synchronized会自动释放锁，lock需要手动释放锁，所以一般lock的释放要放在finally代码块中，synchronized不可中断，lock是可中断锁。

## countdownlatch和cyclicbarrier的区别

> countdownlatch是减法计数器，当计数器减至0时释放锁，cyclicbarrier是加法计数器，计数器加到指定值时释放锁

| CountDownLatch                                               | CyclicBarrier                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 减计数方式                                                   | 加计数方式                                                   |
| 计算为0时释放所有等待的线程                                  | 计数达到指定值时释放所有等待线程                             |
| 计数为0时，无法重置                                          | 计数达到指定值时，计数置为0重新开始                          |
| 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 |
| 不可重复利用                                                 | 可重复利用                                                   |

## jvm方法区里都有什么,方法区会oom吗

> - 方法区主要存储虚拟机加载的类信息、常量、静态变量、及编译器编译后的代码缓存、类加载器。
> - 方法区同样会发生OOM

## AtomicInteger底层实现

> AtomicInteger底层使用volatile修饰了value保证可见性并调用了unsafe类的compareAndAddInt方法，是本地方法，使用自旋锁实现。

## jvm内存结构

> JVM中包含堆、栈、本地方法栈、程序计数器、方法区。
>
> 堆是线程共享，存储创建的对象。
>
> 栈是线程私有，存储局部变量表、操作栈、动态链接、方法出口、对象指针等信息。
>
> 本地方法栈是线程共享，存储本地方法。
>
> 程序计数器是线程私有，存储线程执行的下一条语句。
>
> 方法区是线程共享，存储静态变量、类信息、常量

## 类加载器，创建一个String对象的过程，创建一个类在内存中的过程

> 类加载器分为启动类加载器，扩展类加载器，系统类加载器，用户自定义的类加载器
>
> 会首先创建一个String对象，对于初始的字符串会去字符串常量池中寻找字符串，如果存在则返回，不存在则创建一个字符串放在字符串常量池中。
>
> 创建类，首先为检查是否有父类，为父类分配空间并按照代码顺序初始化static常量和执行static方法，再加载子类的static常量和static方法，再初始化父类的普通变量和代码块和构造器，最后初始化子类的普通变量并执行代码块和构造器。

## 双亲委派模型，一个同包同名的类如何加载。

> 双亲委派模型即类加载器在加载一个类时，首先要求父级加载器加载，可以有效防止java核心包被篡改。
>
> 如果两个包属于不同类加载器加载，那么优先加载所属加载器级别更高的那个类，如果属于同一个类加载器，则根据系统的文件排序加载先被扫描的类。

## 100000000个数找中位数

> 如果可以放入内存，则随机取一个数，将比这个数小的值放在左边，比这个数大的值放在右边。操作完成后可以知道选取的数字是第几大数字，如果该数字比中位数小，则对该数字右侧进行同样操作，一直取到第50000000大数字和第50000001大数字取平均值。
>
> 如果不能放入内存，首先按照内存大小计算出组数，比如内存中可以存放10000000个数字，则将数据分为100000000/10000000=10组，第一组存放值位于1~10000000区间的数字，以次类推，通过统计每组的容量可以得出数字位于哪个组中，再通过方式一求得中位数。

## http，为什么用TCP

> 答案未知！
>
> TCP是可靠的传输，在之前的网络中，UDP经常出现丢包现象，这会造成HTTP解析失败，需要因此重传多次数据，这样造成的损失远远大于TCP传输。
>
> 如今的网络连接质量越来越好，丢包现象罕见，在HTTP3.0中便使用了UDP进行传输，这样可以减少服务器的连接数，大幅提高服务器的性能。

## 三次握手，DNS为什么用UDP

> 客户端先发送一个带有请求建立连接的状态码1和一个序列码seq=X数据包给服务器代表请求连接服务器，服务器收到数据包后回复带有ACK=1 ACKnum=X+1      SYN=1 seq=Y的数据包给客户端，客户端收到后发送带有ACK=1和ACKnum=Y+1的数据包给服务器并进入ESTABLISHED状态，服务器收到数据包后也进入ESTABLISHED状态，连接正式建立。       

## 输入网址到返回页面的过程

## Mysql为什么用B+树，

## 非聚类索引，聚类索引

## 二叉树蛇形打印
