1. 给我讲讲hashMap 

   >hashMap使用Node节点保存key-value,其中还有一个存储Node节点的数组作为hash桶，当调用put方法时，hashmap首先计算出key的hash值，并通过计算所得的hash值算出在数组中的位置。若数组中该位置为空，则直接将Node插入数组中，若不为空，则判断与该位置节点的key是否相同，相同则替换原value为新value。若不同，则判断该节点是否为TreeNode，如果是树节点，则执行红黑树插入操作，如果不是，则将节点通过尾插法插入链表。插入完成后，判断是否需要对数组扩容。

2. 我有一个Student对象，如果使用hashMap，需要重写什么 

   > 如果将Student作为key来使用，则需要重写equals方法和hashcode方法。

3. 扰动的[算法]() 

   > 计算得到的hash值是一个int型，如果只是取低位的hash值很容易造成低位相同，高位不同的hash值发生碰撞，所以hashmap采用了扰动的方式，将hash值的高16位与低16位进行异或得到一个更加散列的16位的hash值

4. 扩容机制 

   > 在JDK1.8之后，当第一次调用put方法会进行扩容，此时的扩容是初始化数组，数组大小为第一个大于设定值的2的幂来初始化，如果未设定初始值，会使用16来进行初始化。如果hashmap中的节点数量超过了负载因子定义的容量，则进行hash数组的扩容，将数组扩大为两倍，并将元素进行迁移。

6. 枚举类，避免多个if 

   

6. 讲一讲同步锁（Synchronized和Lock） 

   > Synchronized 是java提供的关键字，是悲观非公平锁，是可重入锁，不需要程序员手动释放锁，线程出现异常时也可以自动释放锁。底层是使用指令码来实现的，monitorenter和monitorexit。是不可中断锁。
   >
   > Lock是一个接口，Lock需要手动释放锁，所以应该在finally中释放锁，Lock更加灵活，可以对不同的condition进行等待和唤醒操作，实现精准唤醒。是可中断锁。//底层是使用乐观锁来实现的

7. 输入URL的过程

   > 1. 在浏览器中输入URL时，浏览器会在缓存中加载相关URL并提示，当按下回车后，便进行DNS域名解析，首先在浏览器缓存中查询相关的解析结果，如果没有再去本地hosts文件查询，找不到的话去询问ISP中是否有对应的ip地址，如果没有ISP会向根DNS服务器进行查询，根服务器中如果没有，便递归向子服务器进行查询。查询到对应的ip之后，会将对应关系保存在缓存中以备下次查询
   > 2. 查询到ip地址后，向服务器建立请求建立TCP连接，客户端发送包含SYN=1，seq=X的TCP连接请求，服务端接收到后，向客户端发送SYN=1，seq=Y，ACK=1，ACKnum=X+1的连接请求，客户端接收到后，发送ACK=1.ACKnub=Y+1的确认包，服务器接收到之后，双方进入EStablished状态。此时TCP连接建立成功。
   > 3. 客户端向服务端发送HTTP请求，请求报文分为请求行，请求头，请求正文 请求行包含请求方法、URL、协议版本 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。
   > 4. 服务端处理请求并返回HTTP报文 
   > 5. 浏览器根据HTTP报文进行页面渲染。
   > 6. 断开TCP连接
   
8. spring、springMvc、springBoot和springCloud

    > **spring和springMvc：**
    >
    > 1. spring是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案；
    >
    > 2. springMvc是spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于spring框架中WEB层开发的一部分；
    >
    > **springMvc和springBoot：**
    >
    > 1. springMvc属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂；
    > 2. springBoot框架相对于springMvc框架来说，更专注于开发微服务后台接口，不开发前端视图；
    >
    > **springBoot和springCloud：**
    >
    > 1. spring boot使用了默认大于配置的理念，集成了快速开发的spring多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置，是一套快速配置开发的脚手架，能快速开发单个微服务；
    >
    > 2. spring cloud大部分的功能插件都是基于springBoot去实现的，springCloud关注于全局的微服务整合和管理，将多个springBoot单体微服务进行整合以及管理； springCloud依赖于springBoot开发，而springBoot可以独立开发；
    >
    > **总结：**
    >
    > 1. Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring的ioc、aop等. ioc 提供了依赖注入的容器， aop解决了面向横切面编程，然后在此两者的基础上实现了其他延伸产品的高级功能；
    >
    > 2. springMvc是基于Servlet 的一个MVC框架主要解决WEB开发的问题，因为Spring的配置非常复杂，各种XML、JavaConfig、servlet处理起来比较繁琐；
    >
    > 3. 为了简化开发者的使用，从而创造性地推出了springBoot框架，默认优于配置，简化了springMvc的配置流程；
    >    但区别于springMvc的是，springBoot专注于微服务方面的接口开发，和前端解耦，虽然springBoot也可以做成springMvc前后台一起开发，但是这就有点不符合springBoot框架的初衷了；
    >
    > 4. 对于springCloud框架来说，它和springBoot一样，注重的是微服务的开发，但是springCloud更关注的是全局微服务的整合和管理，相当于管理多个springBoot框架的单体微服务；

9. springboot自动装配

    >SpringBoot首先可以看到启动类上的注解是SpringBootApplication，这个注解包括了Configuration、EnableAutoConfiguration、ComponentScan三个注解，自动装配的核心注解就是EnableAutoConfiguration，这个注解的注释引导我们去看AutoConfigurationImportSelector这个类，这个类实现了ImportSelector接口中的selectImport方法，这个方法从meta-inf/Spring.factories中加载所要自动装配的类并将这些类加载到IOC容器中，自动装配就完成了

10. redis跳表以及为什么要用跳表

    > 跳表是一种有序的多层的链表，跳表的复杂度与红黑树相同，跳表更容易代码实现也更加易读，跳表区间查找效率更高。

11. redis你都用来干什么(说了缓存和分布式锁)

12. redis分布式锁

13. 一致性hash

     > 一致性hash是在哈希算法的基础上提出的，在动态变化的分布式环境中，一致性哈希可以保证平衡性，单调性，分散性。
     >
     > 他是通过一个叫做一致性哈希环的数据结构来实现的，环的起点是0，终点是2^32^-1,起点与终点连接，计算所得的hash值会被放在环上。
     >
     > 服务器首先计算哈希值并被放在环上，当有对象请求时，计算对象的哈希值并放在环上，所请求的服务器便是顺时针距离对象最近的服务器。
     >
     > 一致性哈希算法可以有效解决分布式系统中，增加或下线服务器缓存大面积失效的情况

14. mysql底层数据结构

15. mysql存储引擎区别

16. springico

17. spring循环依赖

18. rabbitmq消息队列及底层实现原理

19. java里边的锁都有哪些

20. synchronize和lock的区别

21. countdownlatch和cyclicbarrier的区别

22. jvm方法区里都有什么,方法区会oom吗

23. AtomicInteger底层实现

