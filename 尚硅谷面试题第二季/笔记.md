# 对volatile的理解

## volatile是什么

- volatile是Java虚拟机提供的一种轻量级的同步机制
  - 保证可见性
    - 可见性：一个线程修改了主物理内存的值，其他线程立马知道。(详细见下一章JMM是什么)
    - 代码证明：在主线程中使用一个新线程修改某个对象中==未加volatile==修饰的变量，在主线程中使用while循环判断，会发现主线程无法退出循环，使用volatile修饰后可以退出循环。

  - 不保证原子性
    - 原子性：不可分割，完整性，某个线程在做某个业务时，中间不可以被加塞或分割，需要整体完整，要么全部成功，要么全部失败。
    - 代码证明：使用20个线程对==有volatile修饰==的变量进行1000次自增操作，运算结束后结果小于20000。
    - 如何解决原子性：
      - 加synchronized修饰
      - 使用AtomicInteger替换int类型
    
  - 禁止指令重排
    - 在编译过程中，指令不一定按照编写的顺序进行编译，最终运行结果会与编写的顺序不同

    - 代码证明：

      ```java
      int x = 11;(1)
      int y = 12;(2)
      x = x+5;(3)
      y = x*x;(4)
      
      最终执行结果可以是
          (1)(2)(3)(4)
          (2)(1)(3)(4)
          (1)(3)(2)(4)
      由于存在依赖性，语句(4)不可能被重排至前面。
      ```

    - 代码证明2：

      ```java
      int a,b,x,y = 0;
      ```

      | 线程1  | 线程2  |
      | ------ | ------ |
      | x = a; | y = b; |
      | b = 1; | a = 2; |

      正常无指令重排

      ```java
      x = 0;
      y = 0;
      b = 1;
      a = 2;
      ```

      指令重排后可能出现

      | 线程1  | 线程2  |
      | ------ | ------ |
      | b = 1; | a = 2; |
      | x = a; | y = b; |

      运行结果

      ```java
      x = 2;
      y = 1;
      a = 2;
      b = 1;
      ```

      





## JMM是什么

> JMM是Java内存模型 ,本身是一种抽象的概念==并不真实存在==，描述的是一组规则或规范，定义了程序中各个变量的访问方式。

线程安全性得到保证

**三大特性**

- 可见性
- 原子性
- 有序性

**可见性的具体描述**：

> 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量	的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝	，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:

![image-20210509161907279](C:\Users\wtq\Desktop\笔记\尚硅谷面试题第二季\images\image-20210509161907279.png)

## 在哪里使用到了volatile

### 单例模式

```java
public static SingletonDemo getInstance(){
    if(instance == null){
        synchronized (SingletonDemo.class){
            if(instance == null){
                instance == new SingletonDemo();
            }
        }
    }
    return instance;
}

这种双端检锁机制的单例模式看起来没有问题，但由于指令重排，有可能造成SingletonDemo还没有被初始化完成时instance指向了将要被初始化的内存区域，此时如果有其他线程获取instance，会判断为非空，但是实际上instance指向的内存区域是空内存。
    
因此需要在instance前添加volatile修饰。
```

# CAS

## 什么是CAS？

CAS就是比较并交换，==compare and swap==，是一条CPU并发原语。

在进行CAS操作时，==先对期望值与实际值进行比较==，如果相同，代表在之前没有线程修改过该对象，则此时可以修改。如果不同，代表之前有其他线程对该对象进行过操作，此时不能修改，否则将违背原子性。

## 底层原理？

自旋锁，unsafe类

#### unsafe类是什么？

unsafe类是位于rt.jar中的一个类，其方法都是native方法，都直接调用操作系统底层资源执行相应任务。

unsafe类通过valueOffset进行操作，valueOffset即内存偏移量。

```java
public final int getAndIncrement(){
    return unsafe.getAndAddInt(this,valueOffset,1);
}

//****************************************

public final int getAndAddInt(Object var1,long var2,int var4){
    int var5;
    do {
        var5 = this.getIntVolatile(var1,var2); //获取对应的值
    } while(!this.compareAndSwapInt(var1,var2,var5,var5 + var4)); //cas操作，成功则跳出循环
    return var5;
}
```

## 缺点？

- 由于有do while循环，循环时间长，cpu开销大。
- 只能保证一个共享变量的原子性。
- 出现ABA问题。

# ABA问题

## 怎么产生的？

狸猫换太子

比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。

尽管操作成功，但是不能说明过程没有问题。

## 怎么解决？

### 原子引用

使用stamp来作为版本号记录变化，每次修改使stamp加一，这样便可以避免ABA问题

# 集合类不安全

## 并发修改异常

在使用ArrayList等线程不安全的集合类时，多线程环境下对集合进行操作会出现并发修改异常。

```java
java.util.ConcurrentModificationException
```

#### 如何解决

- vector(弃用)
- Collections.synchronizedList(new ArrayList<>());
- CopyOnWriteArrayList()；

## 写时复制

CopyOnWriteArrayList()；实现方法即为写时复制。

> 先将Array复制一份，修改完成后，将原来的引用修改至新的Array，实现了读写分离。

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();//复制
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);//扩容
        newElements[len] = e;//add
        setArray(newElements);//修改引用
        return true;
    } finally {
        lock.unlock();
    }
}

final void setArray(Object[] a) {
    array = a;
}
```



## Set

==CopyOnWriteArraySet==底层使用了CopyOnWriteArrayList来实现。

## Map

使用==ConcurrentHashMap==解决Map线程不安全问题

# 锁

ReentrantLock() 默认是非公平锁，相当于ReentrantLock(false)，相反的，ReentrantLock(true)即为公平锁

非公平锁比公平锁的优点在于吞吐量大。

synchronized 也是一种非公平锁。

## 公平锁

多个线程按照申请锁的顺序来获取锁，先来后到

## 非公平锁

多个线程不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，高并发的情况下有可能造成优先级反转或者饥饿现象。

## 可重入锁（递归锁）

### 是什么

同一线程外层函数获得锁之后，内层递归函数仍然能够获取该锁的代码，在同一线程外层方法获取锁的时候，在进入内层方法时会自动获取锁。

也就是说，==线程可以进入任何一个它已经拥有的锁所同步着的代码块==。

### 例子

ReentrantLock/Synchronized就是典型的可重入锁。

### 作用

可重入锁最大的功能是避免死锁。	

### 代码验证

synchronized是可重入锁。

```java
public void synchronized sendSMS(){
    //do something;
    sendEmail();
}

public void synchronized sendEmail(){
    //do somthing;
}

main(){
    sendSMS();
}

运行结果：
    短信发送成功
    邮件发送成功
```

ReentrantLock是可重入锁

```java
Lock lock = new ReentrantLock();

public void sendSMS(){
    lock.lock();
    //do something;
    sendEmail();
    lock.unlock();
}

public void sendEmail(){
    lock.lock();
    //do somthing;
    lock.unlock();
}

main(){
    sendSMS();
}

运行结果：
    短信发送成功
    邮件发送成功
```

## 自旋锁

尝试获取锁的对象不会立即阻塞，而是==采用循环的方式去获取锁==，好处是减少了线程的上下文切换的消耗，缺点是循环会消耗CPU。

### 手写自旋锁

```java
public class SpinLockDemo {
    AtomicReference<Thread> atomicReference = new AtomicReference<>();
    public void myLock(){
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName()+" come in");
        while (!atomicReference.compareAndSet(null,thread)){
        }
    }
    public void myUnlock(){
        Thread thread = Thread.currentThread();
        atomicReference.compareAndSet(thread,null);
        System.out.println(thread.getName()+" unlocked");
    }
    
    public static void main(String[] args) {
        SpinLockDemo spinLockDemo = new SpinLockDemo();
        new Thread(() -> {
            spinLockDemo.myLock();
            try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }
            spinLockDemo.myUnlock();
        },"AA").start();
        new Thread(() -> {
            spinLockDemo.myLock();
            spinLockDemo.myUnlock();
        },"BB").start();
    }
}
//AA come in
//BB come in
//AA unlocked
//BB unlocked
```

## 独占锁

该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁。

## 共享锁

指该锁可以被多个线程所持有

ReentrantReadWriteLock其读锁是共享锁，写锁是独占锁

读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的



代码演示

```java
public class ReentrantReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();
        for (int i = 0; i < 5; i++) {
            int finalI = i;
            new Thread(() -> {
                myCache.put(String.valueOf(finalI),String.valueOf(finalI));
            },String.valueOf(i)).start();
        }
        for (int i = 0; i < 5; i++) {
            int finalI = i;
            new Thread(() -> {
                myCache.get(String.valueOf(finalI));
            },String.valueOf(i)).start();
        }
    }
}

class MyCache{
    private volatile Map<String,Object> map = new HashMap<>();
    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    public void put(String key,Object value)
    {
        readWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName()+"写入。。。"+key);
            try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
            map.put(key,value);
            System.out.println(Thread.currentThread().getName()+"写入完毕。。。");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.writeLock().unlock();
        }
    }
    public void get(String key)
    {
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName()+"读取。。。");
            try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
            Object result = map.get(key);
            System.out.println(Thread.currentThread().getName()+"读取完毕。。。"+result);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }
    }
}

0写入。。。0
0写入完毕。。。
1写入。。。1
1写入完毕。。。
4写入。。。4
4写入完毕。。。
2写入。。。2
2写入完毕。。。
3写入。。。3
3写入完毕。。。
2读取。。。
1读取。。。
0读取。。。
4读取。。。
3读取。。。
2读取完毕。。。2
4读取完毕。。。4
1读取完毕。。。1
3读取完毕。。。3
0读取完毕。。。0
```

# CountDownLatch/CyclicBarrier/Semaphore

## CountDownLatch

秦王灭六国，一统天下。

用来计数的类，在调用await方法时会阻塞，使用countDown方法使计数减一，计数减到0时可以放行线程。

```java
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(6);//创建一个计数6次的计数器
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName()+"号同学离开教室");
                countDownLatch.countDown();
            },String.valueOf(i)).start();
        }

        countDownLatch.await();
        System.out.println("班长锁门");
    }
}
```



## CyclicBarrier

集齐七颗龙珠，召唤神龙。

用来计数的类，在调用await方法时会阻塞，计数增加到设定值时放行所有等待的线程，并进行操作。

```java
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,() -> {
            System.out.println("召唤神龙");
        });
        for (int i = 0; i < 7; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName()+"收集到龙珠！");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

## Semaphore

多个线程争夺多个资源时使用，类似对剩余资源的计数。

```java
public class SemaphoreDemo {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3); //3个资源
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName()+"抢到车位！");
                    try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

# synchronized与Lock

## 有什么区别

### 原始构成

- synchronized关键字属于JVM层面
- Lock是具体的类（java.util.concurrent.locks.Lock）是具体层面的锁

### 使用方法

- synchronized不需要用户手动释放锁，代码块执行结束后会自动释放锁。
- ReentrantLock需要用户手动释放锁，若没有主动释放锁，可能造成死锁。
  - 需要lock()和unlock()方法配合try/finally使用

### 等待是否可中断

- synchronized不可中断，除非抛出异常或者正常运行完成
- ReentrantLock可中断。
  - 设置超时方法 tryLock(long timeout,TimeUnit unit)
  - lockInterruptibly()放代码块中，调用interrupt()方法即可中断

### 加锁是否公平

- synchronized非公平锁

- ReentrantLock可设置公平或非公平，默认非公平锁

### 锁绑定多个条件Condition

- synchronized不支持
- ReentrantLock用来实现分组唤醒的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。

### Condition实例

```java
```



# 阻塞队列

## 性质

当队列为空时，从队列中获取元素的线程会被阻塞。

当队列为满时，向队列中添加元素的线程会被阻塞。

## 常用阻塞队列

- ==ArrayBlockingQueue==：用数组组成的有界（无默认值）阻塞队列
- ==LinkedBlockingQueue==：用链表组成的有界（默认为Integer.MAX_VALUE）阻塞队列
- PriorityBlockingQueue：支持优先级排序的无界阻塞队列
- DelayQueue：使用优先级队列实现的延迟无界阻塞队列
- ==SynchronousQueue==：不存储元素的阻塞队列，即单个元素的阻塞队列(put方法必须等待一个take方法才可以结束)
- LinkedTransferQueue：由链表组成的无界阻塞队列
- LinkedBlocking**Deque**：有链表组成的双向阻塞队列

SynchronousQueue代码演示

```java
public class SynchronousQueueDemo {
    public static void main(String[] args) {
        SynchronousQueue synchronousQueue = new SynchronousQueue();
        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName()+"put 1");
                synchronousQueue.put(1);
                System.out.println(Thread.currentThread().getName()+"put 2");
                synchronousQueue.put(2);
                System.out.println(Thread.currentThread().getName()+"put 3");
                synchronousQueue.put(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"AAA").start();

        new Thread(() -> {
            try {
                try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
                System.out.println(Thread.currentThread().getName()+"take");
                synchronousQueue.take();
                try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
                System.out.println(Thread.currentThread().getName()+"take");
                synchronousQueue.take();
                try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
                System.out.println(Thread.currentThread().getName()+"take");
                synchronousQueue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"BBB").start();
    }
}
AAAput 1
BBBtake
AAAput 2
BBBtake
AAAput 3
BBBtake
```



## 阻塞队列有没有好的一面

程序员不需要关心什么时候阻塞线程，什么时候唤醒线程，全部交给BlockingQueue来做。

## 如何使用

| 方法 | 抛出异常  | 特殊值   | 阻塞   | 超时               |
| ---- | --------- | -------- | ------ | ------------------ |
| 插入 | add(e)    | offer(e) | put(e) | offer(e,time,unit) |
| 移除 | remove()  | poll()   | take() | poll(time,unit)    |
| 检查 | element() | peek()   | 不可用 | 不可用             |

解释

- 抛出异常
  - 队列满时调用add方法会抛 IllegalStateException: Queue full 异常
  - 队列空时调用remove方法会抛 NoSuchElementException 异常
  - 队列空时调用element方法会抛 NoSuchElementException 异常
- 特殊值
  - 插入成功返回true 插入失败返回false
  - 队列空时调用peek方法返回 null
  - 队列空时调用poll方法返回 null
- 阻塞（官方示意图使用）
  - 队列满时调用put方法会阻塞线程
  - 队列空时调用take方法会阻塞线程
- 超时
  - 队列满时调用offer(e,time,unit)方法会尝试插入，time时间后仍未插入成功则返回false
  - 队列空时调用poll(time,unit)方法会尝试移除元素，time时间后仍未移除成功则返回false

## 不得不阻塞，如何管理

